# Trace

目前应该不存在万能的 Trace ID 生成策略能够满足所有的场景.而对场景添加一些约束后,还是可以设计出一种 ID 生成策略,并通过这个 ID 完成追踪.

## 约束条件

### 服务端线程必须向前一个请求发送完响应后才能开始接收第二个请求的数据

满足约束的情况

```plaintext
┌─────────────────────────┐
│      Server Thread      │
└─▲─────┬────────▲─────┬──┘
  │     │        │     │
  │     │        │     │
┌─┴─────▼──┐   ┌─┴─────▼──┐
│ Client A │   │ Client B │
└──────────┘   └──────────┘
```

不满足约束的情况

```plaintext
┌─────────────────────────┐
│      Server Thread      │
└─▲───▲───▲────┬────┬───┬─┘
  │   │   │    │    │   │
┌─┴───┴───┴────▼─┐  │   │
│    Client A    │  │   │
└─────┬───┬──────┘  │   │
      │   │         │   │
     ┌┴───┴─────────▼─┐ │
     │    Client B    │ │
     └────┬───────────┘ │
          │             │
         ┌┴─────────────▼─┐
         │    Client C    │
         └────────────────┘
```

## Trace ID 的生成策略

当服务端线程收到请求时生成 Trace ID,在对这个请求完成响应并收到下一个请求时生成下一个 Trace ID.

以下图为例,当 Server Thread 收到 Client A 发送的请求时,生成新的 Trace ID,在整张图中,都没有出现第二个请求,因此全图中所有的箭头**对于 Server Thread 来说**有相同的 Trace ID.

上面强调了关于 Trace ID 的讨论仅针对 Server Thread, 是因为这里的 Trace ID 效果与 HTTP 在 Header 里写的 X-Request-Id 有区别. X-Request-Id 添加到报文里,可以一直向后传递.而 Trace ID 只是分析程序的行为,并生成一个与线程相关的值,这个值没法传递给其他进程.

```plaintext
 ┌──────────────────────────────────────────────────┐
 │                    Backend D                     │
 └▲───────────────────────────────────────────────┬─┘
  │                                               │
  │ ┌───────────┐   ┌───────────┐   ┌───────────┐ │
  │ │ Backend A │   │ Backend B │   │ Backend C │ │
  │ └─▲─┬──▲─┬──┘   └──▲──┬──┬──┘   └──▲─▲─▲─▲──┘ │
  │   │ │  │ │         │  │  │         │ │ │ │    │
  │   │ │  │ │         │  │  │         │ │ │ │    │
  │   │ │  │ │         │  │  │         │ │ │ │    │
┌─┴───┴─▼──┴─▼─────────┴──▼──▼─────────┴─┴─┴─┴────▼─┐
│                   Server Thread                   │
└▲─────────────────────────────────────────────────┬┘
 │                                                 │
 │                                                 │
┌┴─────────────────────────────────────────────────▼┐
│                     Client A                      │
└───────────────────────────────────────────────────┘
```

## 区分客户端请求与后端的响应

客户端请求与后端的响应对于 Server Thread 来说都是一次报文的读操作.前者需要更新 Trace ID, 而后者不需要.现在需要一种明确的方法在收到一个包时判断来自客户端还是后端.

对于一个服务来说,它有明确监听的端口,来自监听端口的数据一定来源于客户端且来源于客户端的数据一定通过监听的端口接收.因此只需要在收发报文时,判断本地端口是否为监听的端口.

需要维护一个特定的数据接口,可以查看特定进程号对应的特定端口号是否为监听端口.
